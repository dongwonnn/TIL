## Core Javascript 2

## 호이스팅

### 함수의 호이스팅

함수 선언식 vs 함수 표현식
함수 선언식은 어느 위치에 있어도 가능
함수 표현식은 할당된 함수가 호이스팅 시점에 올라오지 않음

### let, const의 hoisting

var는 hoisting 이 되는건 맞음, let, const는 hoisting 되는건 맞음. 하지만 할당이 되기전까진 TDZ안에 있다.

Temporal Dead Zone (TDZ)
호이스팅 해서 알긴알아 미리 땡겨오게 했지만 못쓰게 막아놨음.
lexical 환경에서 정보는 가지고 있으면서도 못쓰게 하는 공간을 TDZ라고 함.

퀴즈
var x 3개는 모두 다 다른 x라고 생각하자. 맨 위로 끌어올셔서 생각

### SCOPE

즉시 실행 함수. VAR를 이용하다보니 안에서만 한정하고 싶어서 사용했었음.
지금은 let, const변수를 사용해서 블록 단위{}로 변하게 된다.
var, let, const 차이점 하나 더. scope

#### scope chain

함수들이 체인형태로
이름은 충돌했다면 별개의 스코프, 별개의 변수다. 나의 스코프안에 변수가 없다면 밖의 스코프에 변수를 찾음
변수들이 여러개가 있다면 가장 가까운 변수를 찾는것

## this

### 함수와 메서드

메서드: 객체로 propperty로 함수가 정의됐을 때. 점찍고 호출해야할 때

### this

this는 바라보고 있는 객체인데, 상황에 따라 달라지는 대상이 달라집니다.

this는 함수를 호출할 때 결정된다.

#### this 동작 방식

1. 전역공간에서 this는 window 객체다.
2. 메서드로 호출 될 때. 호출될 때 알 수있다. 객체.메서드라면 메서드의 this는 .앞에있는 객체를 가리킨다.
   앞에 호출된게 없으면 전역객체를 가리킨다.

#### call, apply, bind

call, apply

bind : 명시적으로 어떤 객체를 쓰겠어라고 넘기지만 호출하지않고 묶어놓기만한다.
이벤트객체에서 this를 사용하면, this를 엘레먼트를 바라봄. 하지만 리액트는 setState를 사용하고 싶다.
this는 호출할때 결정하는데 이벤트객체는 사용자가 클릭했을 때 호출하다보니 통제가 불가능.

arrow fucntion의 가장 큰 거 = this 사용
arrow 안에서 this는 undefined. 호출할때 결정되지 않고 하나 바깥에 있는 스코프 체인 객체를 가리킴.
